## 1、运行流程

1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取；（CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。 2、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数； key是按照某种策略生成的；默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key； SimpleKeyGenerator生成key的默认策略； 如果没有参数；key=new SimpleKey()； 如果有一个参数：key=参数的值 如果有多个参数：key=new SimpleKey(params)；

3、没有查到缓存就调用目标方法；

4、将目标方法返回的结果，放进缓存中

**@Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存**， **如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据；**

## 常用注解

**@Cacheable**

**根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接取缓存数据返回，如果不存在则执行方法，并把返回的结果存入缓存中，一般用在查询方法上。**

参数：

value：缓存名称（必填），指定缓存的命名空间；
key：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义，如果不指定，则缺省按照方法的所有参数进行组合；
unless：条件符合则不缓存；
condition：条件符合则缓存。

key生成的规则

![image-20201118202738443](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20201118202738443.png)

**@CachePut**

**使用该注解方法每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库，一般用在新增方法上。**

参数：

value：缓存名称（必填），指定缓存的命名空间；
key：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义，如果不指定，则缺省按照方法的所有参数进行组合；
unless：条件符合则不缓存；
condition：条件符合则缓存。

**@CachEvcit**

参数：

value：缓存名称（必填），指定缓存的命名空间；
key：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义，如果不指定，则缺省按照方法的所有参数进行组合；
allEntries：是否清空所有缓存，默认为false，如果指定为true，则方法调用后将立即情况所有的缓存
beforeInvocation:是否在方法执行前就清空，默认为false，指定为true，则方法执行前就会清空缓存